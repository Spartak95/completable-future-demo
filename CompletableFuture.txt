CompletableFuture կլասս է, որը ռելիազացնում է Future և CompletionStage ինտերֆեյսները։ Այս կլասսը հնարավորություն է տալիս
ղեկավարել ասինխրոն օպերացիաների կատարման արդյունքը: Այս կլասսում նեռարվում է հետևյալ արդյունքերը՝
1․ օպերացիայի ավարտման սպասում(հաջող կամ անհաջող): get* և join մեթոդները:
2. օպերացիայի ավարտման notification: complete* մեթոդները
3․ կոմպոզիցիոն ֊ գոյություն ունեցող օբյեկտների հիմքի վրա նոր CompletableFuture օբյեկտների ստեղծում։ Այլ կերպ ասած
   dependent operation֊ները: then*, when*, handle* մեթոդները

Այս կլասսը այն նախագծված է շատ պարզ: Միայն երկու field կա:
   volatile Object result;
   volatile Completion stack;

Չավարտված օպերացիաների համար result դաշտը հավասար է null֊ի: Ավարված օպերացիաների համար կա մի քանի տարբերակները՝
1․ NIL - հատուկ արժեք, որը նշանակում է ավարտված օպերացիան, որի արդյունքը հավասար է null-ի:
2․ java.util.concurrent.CompletableFuture.AltResult instance, որը պարունակում է օբյեկտ exception, եթե օպերացիան cancel է
   եղել կամ ավարտվել է exception-ով:
3․ Օպերացիայի անմիջական արդյունքը, որը wrapped եղած չէ ինչ֊որ օբյեկտի մեջ, այսինքն հենց այն օբյեկտը, որը ստեղծել է user-ը:

Future-ում ոչ մի cancelled flag չկա: Future-ում չեղարկվում է cancel մեթոդի օգնությամբ, որը պարունակում է սովորական AltResult
CancellationException֊ով: Այսինքն result համար կլինի 3 տարբերակը:

null / ոչ null ֊ դա ձև է ստուգել Future֊ը ավարտվել է թե չէ։ isDone մեթոդը հենց դա է անում։ isCancelled ստուգում է
exception-ի տիպը։ isCompletedExceptionally մեթոդի դեպքում ստուգում էմ որը result-ը հանդիսանում է AltResult֊ի instance-ը
և հավասար չէ NIL(NIL ինքնը իրենով հավասար է new AltResult(null))։

stack ֊ պարունակում է գործողությունների կոլլեկցիա, որը պետք է կատարվի մինչև Future֊ի ավարտվելը:

Ո՞վ և ինչպես է ավարտվում future-ները

Future-ները կարող են ավարտվել տարբեր պատճառներով։
Առաջին հերթին ֊ ծրագրավորողը կարող է ինքնուրույն կանչել complete/completeExceptionally/cancel մեթոդները։
Երկրորդ հնարավոր պատճառը ֊ կոդի ավարտը, որը ասոցացվում է instance-ի հետ։ Օրինակ՝ CompletableFuture#runAsync-ին փոխանցված
Runnable֊ը կատարվում է։ Այսինքն՝ մի իրավիճակ, երբ ծրագրավորողը ձեռքով չի հատկացրել future։
Երրորդ հնարավոր պատճառը ֊
Третья причина - была закомпличена source фьюча. В API CompletionStage огромное число методов, которые
возвращают разработчику новые инстансы, зависимые от ранее имеющегося объекта. Например: